<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE stylesheet>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  version="1.0" >

<xsl:preserve-space elements="codesection"/>
  <xsl:output method="text"/>

  <xsl:template match="/DoolpObjects">
/*
  Generated by XSLT transform.
  Version A.2.8-n23
    * Implementing DoolpException
    * Implementing DoolpSlot
*/
#define __DOOLP_INCLUDES_FOR_DOOLPCC__
#include &lt;doolp.h&gt;
using namespace Doolp;
/*
    Sortie pour DoolpObjects... 
   Valeur de generateDoolpObjectsInfo : <xsl:value-of select="@generateDoolpObjectsInfo"/>
  */


  <xsl:if test="@DoolpObjectsInfoExtern = 'true'">
extern "C"
  </xsl:if>
bool registerDoolpObjects(Doolp::Forge * forge);

  

  // Code for objects :
  <xsl:apply-templates select="Object"/>
  // Code for exceptions : 
  <xsl:apply-templates select="Exception"/>

bool registerDoolpObjects(Doolp::Forge * forge)
{
  <xsl:for-each select="Object"><xsl:if test="@name != 'Doolp::Forge'">{ <xsl:value-of select="@name"/> o((Doolp::ObjectId)0); o.__initStatic ( forge ); }
  </xsl:if></xsl:for-each>
  <xsl:for-each select="Exception">{ <xsl:value-of select="@name"/> e; e.__initStatic ( forge ); }
  </xsl:for-each>
  return true;
}


  </xsl:template>

  <xsl:template match="/DoolpObjects/Object">
/*
    DoolpObject : '<xsl:value-of select="@name"/>' (nameId=<xsl:value-of select="@nameId"/>).
    forceObjectAs = '<xsl:value-of select="@forceObjectAs"/>'
 */
  <xsl:if test="@name != 'Doolp::Forge'">
<xsl:for-each select="Include">#include &lt;<xsl:value-of select="@header"/>&gt;
</xsl:for-each>
<xsl:value-of select="@name"/>::<xsl:value-of select="@shortName"/> ( Doolp::ObjectId objId )
{
  Log ( "Construct object with objId='0x%x'\n", objId );
  objectId = objId;
}
</xsl:if><!-- NOT DOOLPFORGE-->
Doolp::Object * __<xsl:value-of select="@nameId"/>__constructor ( Doolp::ObjectId objId )
{
    Doolp::Object * obj = new <xsl:value-of select="@name"/> ( objId );
    obj-&gt;setOptions ();
    __DOOLP_Log ( "New Object <xsl:value-of select="@name"/> : %p\n", obj );
    __DOOLP_Log ( "Options : contextDependant=%s, ttl=%d\n",
                  obj->isContextDependant () ? "true" : "false",
                  (int) obj->getTTL () );
    obj-&gt;__initSlots ();
    return obj;
}

<xsl:choose>
  <xsl:when test="@forceObjectAs">
// Forced as <xsl:value-of select="@forceObjectAs"/>
Doolp::ObjectNameId <xsl:value-of select="@name"/>::getNameIdStatic ( ) 
  { return <xsl:value-of select="@forceObjectAs"/>::getNameIdStatic (); }
  </xsl:when>
  <xsl:otherwise>
Doolp::ObjectNameId <xsl:value-of select="@name"/>::getNameIdStatic ( ) { return <xsl:value-of select="@nameId"/>; }
  </xsl:otherwise>
</xsl:choose>
Doolp::ObjectNameId <xsl:value-of select="@name"/>::getNameId ( ) { return getNameIdStatic (); }
<xsl:for-each select="Parameter">DoolpObjectParam__StaticValues ( <xsl:value-of select="@line"/>, <xsl:value-of select="../@name"/>, <xsl:value-of select="@index"/>, <xsl:value-of select="@type"/> );
</xsl:for-each>
<xsl:for-each select="Link">DoolpObjectLink__StaticValues ( <xsl:value-of select="@line"/>, <xsl:value-of select="../@name"/>, <xsl:value-of select="@index"/>, <xsl:value-of select="@linkType"/>, <xsl:value-of select="@type"/> );
</xsl:for-each>
<xsl:for-each select="Slot">DoolpObjectSlot__StaticValues(<xsl:value-of select="@line"/>, <xsl:value-of select="../@name"/>, <xsl:value-of select="@index"/>, "<xsl:value-of select="@name"/>&lt;<xsl:value-of select="@signature"/>&gt;",<xsl:value-of select="@signature"/>);
</xsl:for-each>
<xsl:for-each select="SlotHelper"><xsl:if test="@type = 'local'">DoolpObjectSlot__PerClass(<xsl:value-of select="../@nameId"/>,<xsl:value-of select="@name"/>);
</xsl:if></xsl:for-each>

Doolp::ObjectSlotMap __DoolpObject__<xsl:value-of select="@nameId"/>__SlotMap;
Doolp::SlotVirtual * <xsl:value-of select="@name"/>::__getSlot ( Doolp::ObjectSlotId slotId )
{
  Doolp::SlotVirtual * slot = NULL;  
  unsigned int offset = __DoolpObject__<xsl:value-of select="@nameId"/>__SlotMap.get(slotId);
  if ( offset != 0 ) slot = ( (Doolp::SlotVirtual *) (((unsigned int)this) +  offset) );
  if ( slot != NULL ) return slot;
  <xsl:for-each select="Inherits">slot = this-&gt;<xsl:value-of select="@class"/>::__getSlot( slotId ) ; if ( slot != NULL ) return slot;
  </xsl:for-each>
  Warn ( "Could not get slot for slotId '0x%x'\n", slotId );
  return NULL;
}
bool <xsl:value-of select="@name"/>::__initStatic (Doolp::Forge * forge)
{
  forge->getObjectStaticInfo()->addObject ( <xsl:value-of select="@nameId"/>,
                                            "<xsl:value-of select="@name"/>",
                                            &amp;__<xsl:value-of select="@nameId"/>__constructor );
  <xsl:for-each select="forceConstructorForObjects">forge->getObjectStaticInfo()->assignObjectConstuctor( this-&gt;<xsl:value-of select="@value"/>::getNameId(), &amp;__<xsl:value-of select="../@nameId"/>__constructor );
  </xsl:for-each>
  <xsl:for-each select="Parameter"><xsl:value-of select="@name"/>.setOffset ( this );
  </xsl:for-each>
  <xsl:for-each select="Link"><xsl:value-of select="@name"/>.setOffset ( this );
  <xsl:if test="@reverse">// Shall set reverse to '<xsl:value-of select="@reverse"/>'
  { <xsl:value-of select="@type"/> u((Doolp::ObjectId)0); <xsl:value-of select="@name"/>.setReverse ( &amp;(u.<xsl:value-of select="@reverse"/>)); u.<xsl:value-of select="@reverse"/>.setReverse ( &amp;<xsl:value-of select="@name"/>); }
  </xsl:if></xsl:for-each>
  <xsl:for-each select="Slot"><xsl:value-of select="@name"/>.setOffset ( this );
  </xsl:for-each>
  <xsl:for-each select="Slot">__DoolpObject__<xsl:value-of select="../@nameId"/>__SlotMap.put(<xsl:value-of select="@name"/>.getSlotId(), ((unsigned int)&amp;<xsl:value-of select="@name"/>) - ((unsigned int)this) );
  </xsl:for-each>
  __assignSlots ();
  __registerSlots (forge);
  <xsl:if test="@name = 'Doolp::Forge'">registerDoolpObjects(this);
  </xsl:if>
  return true;
}
bool <xsl:value-of select="@name"/>::__registerSlots ( Doolp::Forge * forge)
{
  <xsl:for-each select="Slot">forge->getObjectStaticInfo()->addSlot ( <xsl:value-of select="../@nameId"/>,<xsl:value-of select="@index"/>, <xsl:value-of select="@name"/>.getStaticSlot() );
  </xsl:for-each>
  <xsl:for-each select="SlotHelper"><xsl:if test="@type = 'local'">forge->getObjectStaticInfo()->setImplementedSlot ( getNameId(), <xsl:value-of select="@name"/>.getSlotId() );
  </xsl:if></xsl:for-each>
  return true;
}
bool <xsl:value-of select="@name"/>::__initSlots ()
{
  Log ( "assignSlots : this=%p\n", this );
  <xsl:for-each select="Inherits">this-&gt;<xsl:value-of select="@class"/>::__initSlots ();
  </xsl:for-each>
  <xsl:for-each select="SlotHelper"><xsl:if test="@type = 'local'">DoolpObjectSlot__getFunctions(<xsl:value-of select="../@nameId"/>,<xsl:value-of select="@name"/>);
  </xsl:if></xsl:for-each>
  return true;
}
bool <xsl:value-of select="@name"/>::__assignSlots ()
{
  Log ( "assignSlots : this=%p\n", this );
  <xsl:for-each select="Inherits">this-&gt;<xsl:value-of select="@class"/>::__assignSlots ();
  </xsl:for-each>
  <xsl:for-each select="SlotHelper"><xsl:choose><xsl:when test="@type = 'local'"><xsl:value-of select="@name"/>.assign ( &amp;<xsl:value-of select="../@name"/>::doolpfunclocal(<xsl:value-of select="@name"/>));
  <xsl:value-of select="@name"/>.checkOffset ( this );
  DoolpObjectSlot__setFunctions(<xsl:value-of select="../@nameId"/>,<xsl:value-of select="@name"/>);</xsl:when>
  <xsl:when test="@type = 'chooseAgentId'"><xsl:value-of select="@name"/>.assignChooseAgentId ( &amp;<xsl:value-of select="../@name"/>::doolpfunchelper(<xsl:value-of select="@type"/>, <xsl:value-of select="@name"/>));
  </xsl:when>
  <xsl:otherwise>#error Unknown helper : <xsl:value-of select="@type"/>
  </xsl:otherwise>
  </xsl:choose>
  </xsl:for-each>
  return true;
}
<xsl:if test="@name != 'Doolp::Forge'">
bool __<xsl:value-of select="@nameId"/>__initStaticObject (Doolp::Forge* _forge)
{
  __DOOLP_Log ( "initStaticObject\n" );
  <xsl:value-of select="@name"/> o((Doolp::ObjectId)0);
  o.__initStatic (_forge);
  return true;
}
bool <xsl:value-of select="@name"/>::serialize ( Doolp::Connection * conn )
{
  conn->WriteObjectHead ( this );     <xsl:for-each select="Parameter"> 
  conn->setNextBlockIndex ( <xsl:value-of select="@index"/> ); conn->Write ( <xsl:value-of select="@name"/> ); </xsl:for-each> <xsl:for-each select="Link">
  conn->setNextBlockIndex ( <xsl:value-of select="@index"/> ); conn->Write ( <xsl:value-of select="@name"/> ); </xsl:for-each>
    conn->endSubSection ();
    return true;
}
bool <xsl:value-of select="@name"/>::serialize ( Doolp::Connection * conn, Doolp::ObjectParamId paramId )
{
    switch ( paramId )
    { <xsl:for-each select="Parameter">
    case <xsl:value-of select="@index"/>: 
      conn->setNextBlockIndex ( <xsl:value-of select="@index"/> ); 
      conn->Write ( <xsl:value-of select="@name"/> ); break;     </xsl:for-each>
     <xsl:for-each select="Link">
    case <xsl:value-of select="@index"/>: 
     conn->setNextBlockIndex ( <xsl:value-of select="@index"/> ); 
     conn->Write ( <xsl:value-of select="@name"/> ); break;     </xsl:for-each>
    default: Bug ( "Index not handled : 0x%x\n", paramId);
    }
    return true;
}
bool <xsl:value-of select="@name"/>::unserialize ( Doolp::Connection * conn )
{
  unsigned int blockIndex;
  while ( ( blockIndex = conn->getNextBlockIndex () ) )
  {
    __DOOLP_Log ( "Unserialize paramId=0x%x\n", blockIndex );
    switch ( blockIndex )
    { <xsl:for-each select="Parameter">
      case <xsl:value-of select="@index"/>: 
        conn-&gt;Read ( (<xsl:value-of select="@type"/>*)&amp;<xsl:value-of select="@name"/> ); break;    </xsl:for-each>
      <xsl:for-each select="Link">
      case <xsl:value-of select="@index"/>: 
        conn-&gt;Read ( <xsl:value-of select="@name"/> ); break;    </xsl:for-each>
      default:
        <xsl:for-each select="Inherits">if ( this-&gt;<xsl:value-of select="@class"/>::unserialize ( conn ) == true ) break;
        </xsl:for-each>Bug ( "Index not handled : 0x%x\n", blockIndex );
    }
  }
  return true;
}
</xsl:if>
/* Parameters Table */
</xsl:template> <!-- DoolpObject Template-->
<!--
     ***************************************
     Templates for Exceptions
     ***************************************
     -->
<xsl:template match="/DoolpObjects/Exception">// Code for exception : <xsl:value-of select="@name"/>
  <xsl:for-each select="Include">
#include &lt;<xsl:value-of select="@header"/>&gt;</xsl:for-each>
Doolp::ExceptionId <xsl:value-of select="@name"/>::getExceptionId () { return <xsl:value-of select="@nameId"/>; }
Doolp::Exception * __<xsl:value-of select="@name"/>__constructor () { Log ( "New exception <xsl:value-of select="@name"/>\n" ); return new <xsl:value-of select="@name"/>(); }
bool <xsl:value-of select="@name"/>::__initStatic ( Doolp::Forge * forge )
  { return forge->getObjectStaticInfo()->addException ( <xsl:value-of select="@nameId"/>, "<xsl:value-of select="@name"/>", &amp;__<xsl:value-of select="@name"/>__constructor ); }
  </xsl:template>

</xsl:stylesheet>

